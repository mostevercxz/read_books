Machine level representation of programs(P166-P325)
## Preface
Why should we spend our time learning machine code ?
Understand the optimization capabilities of the compiler and analyze the underlying ineffiencies in the code.(Chapter5,maximize the performance of a critical section of code; Chapter 12,program data are shared or kept private by the different threads. How to attack programs and how to guard against them.)

## 3.1 a historical perspective
29K -> 1.4G transistors, 8086, 80286, i386, i486

## 3.2 program encodings
> gcc -Og -o p p1.c p2.c

-Og instructs the compiler to apply a level of optimization that yields machine code that follows the overall structure of the original C code. (preprocessor -> assembly code -> assembler -> linker)

### 3.2.1 machine-level code
Computer systems two important forms of abstraction :

1. the format and behavior of a machine-level program is defined by the instruction set architecture(ISA, processor state, format of instructions, the effect each of these instructions will have on the state)
2. the memory addresses used by a machine-level program are virtual addresses, providing a memory model that appears to be a very large byte array.

**Parts of the processor state** are visible that normally are hidden from the C programmer:

* The program counter (commonly referred to as the PC, and called %rip in x86-
64) indicates the address in memory of the next instruction to be executed.
* The integer register file contains 16 named locations storing 64-bit values.
These registers can hold addresses (corresponding to C pointers) or integer
data. Some registers are used to keep track of critical parts of the program
state, while others are used to hold temporary data, such as the arguments
and local variables of a procedure, as well as the value to be returned by a
function.
* The condition code registers hold status information about the most recently
executed arithmetic or logical instruction. These are used to implement conditional
changes in the control or data flow, such as is required·to implement
if and while statements.
* A set of vector registers can each hold one or more integer or floating-point
values.

The program memory contains the executable machine code for the program, some info required by the os, a run-time stack for managing procedure calls and returns, blocks of memory allocated by the user.

### 3.2.2 code examples
mstore.c

    long mult2(long, long);
    void multstore(long x, long y, long *dest) {
      long t = mult2(x, y);
      *dest = t;
    }

>gcc -Og -S mstore.c
>
>x/14b multstore
>
>gcc -Og -c mstore.c
>
>objdump -d mstore.o

>gcc -Og -o prog main.c mstore.c

Several features about machine code and its disassembled representation are worth noting:

 * x86-64 instructions can range in length from 1 to 15 bytes. The instruction encoding is designed so that commonly used instructions and those with fewer operands requixe a smaller number Rf bytes than do less common ones or ones with more operands
* The instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions.For example, only the instruction pushq %rbx can start with byte value 53.
* The disassembler determines the assembly code based purely on the byte sequences in the machine-code file. It does not require access to the source or assembly-code versions of the program.
* The disassembler uses a: slightly different naming convention for the instructions than does the assembly code generated by gcc. In our example, it has omitted the suffix 'q' from many of the instructions. These suffixes are size designators and can be omitted in most cases. Conversely, the disassembler adds the suffix 'q' to the call and ret instructions. Again, these suffixes can
safely be omitted.

Some differences:
1. The linker has shifted the location of this code to a different range of addresses.
2. the linker filled in the address that the callq instruction should use in function *mult2*
3. two additional lines of code, nop nop, grow the code for the function to 16 bytes.

### 3.2.3 notes on formatting
All of the lines beginning with '.' are directives to guide the assembler and linker, we can generally ignore these.

>gcc -Og -masm=intel mstore.c

We see that the intel and ATT formats differ in the following ways:

 * The Intel code omits the size designation suffixes, We  see instruction push and mov instead of pushq
and movq.
 * The Intel code omits the '%' character in front of register names, using rbx instead of %rbx.
 * The Intel code has a different way of describing locations in memory-for example, QWORD PTR [rbx] rathen than (%rbx)
 * Instructions With multiple operands list them in the reverse order. This can be very confusing when, switching between the two formats.

## 3.3 data formats
1. Intel uses the term "word" to refer to a 16-bit data type.
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/intel_size_types.png "intel_size_types")

2. combining assembly code with C programs
 * write an entire function as a seperate assembly-code file and let the assembler and linker combine this with code we have written in C
 * use the inline assembly feature of gcc, where brief sections of assembly code can be incorporated into a C program using the *asm* directive.

## 3.4 accessing infomation
An x86-64 central processing unit(CPU) contains 16 general-purpose registers storing 64-bit values. These registers are used to store integer data as well as pointers. (original 8086 had eight 16-bit registers, %ax through %bp)

Two conventions arise for what happens to the remaining bytes in the register for instructions that generate less than 8 bytes : 
 * those that generate 1 or 2 byte quantities leave the remaining bytes unchanged
 * those that generate 4 byte quantities set the upper 4 bytes of the register to zero.

The stack pointer %rsp is used to indicate the end position in the run-time stack.
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/integer_registers.png "integer_registers")

### 3.4.1 operand specifiers
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/operand_forms.png "operand_forms")
operand forms:

 1. immediate, constant values, written with a '$' followed by an integer using standard C notation
 2.  register, denotes the contents of a register.
 3.  memory reference, access some memory location, often called effective address.
 
### 3.4.2 data movement instructions


## arithmetic operations
movb, movw, movl, movq
movzbw, movzbl, movzq, movzwl, movzwq
movsbw, movsbl, movesbq, movswl, moveswq, moveslq

pushq S
popq D

leaq S,D 
INC D
DEC D
NEG D
NOT D

ADD S,D
SUB S,D
IMUL S,D
XOR S,D
OR S,D
AND S,D

SAL k, D left shift
SHL k, D left shift(same as SAL)
SAR k, D arithmetic right shift
SHR k, D logical right shift

mulq
imulq
cqto
idivq
divq

##3.6 control
Condition codes:

monotonicity 单调性
penalty 罚款罚金处罚

##Questions
1. How mant bytes is each instructions compiled to in x86 ?
2. How to write an assembly program and compile it ?
3. the implementation of conditional moves in Chapter 4.
