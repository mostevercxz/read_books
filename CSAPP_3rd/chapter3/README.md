Machine level representation of programs(P166-P325)
## Preface
Why should we spend our time learning machine code ?
Understand the optimization capabilities of the compiler and analyze the underlying ineffiencies in the code.(Chapter5,maximize the performance of a critical section of code; Chapter 12,program data are shared or kept private by the different threads. How to attack programs and how to guard against them.)

## 3.1 a historical perspective
29K -> 1.4G transistors, 8086, 80286, i386, i486

## 3.2 program encodings
> gcc -Og -o p p1.c p2.c

-Og instructs the compiler to apply a level of optimization that yields machine code that follows the overall structure of the original C code. (preprocessor -> assembly code -> assembler -> linker)

### 3.2.1 machine-level code
Computer systems two important forms of abstraction :

1. the format and behavior of a machine-level program is defined by the instruction set architecture(ISA, processor state, format of instructions, the effect each of these instructions will have on the state)
2. the memory addresses used by a machine-level program are virtual addresses, providing a memory model that appears to be a very large byte array.

**Parts of the processor state** are visible that normally are hidden from the C programmer:

* The program counter (commonly referred to as the PC, and called %rip in x86-
64) indicates the address in memory of the next instruction to be executed.
* The integer register file contains 16 named locations storing 64-bit values.
These registers can hold addresses (corresponding to C pointers) or integer
data. Some registers are used to keep track of critical parts of the program
state, while others are used to hold temporary data, such as the arguments
and local variables of a procedure, as well as the value to be returned by a
function.
* The condition code registers hold status information about the most recently
executed arithmetic or logical instruction. These are used to implement conditional
changes in the control or data flow, such as is required·to implement
if and while statements.
* A set of vector registers can each hold one or more integer or floating-point
values.

The program memory contains the executable machine code for the program, some info required by the os, a run-time stack for managing procedure calls and returns, blocks of memory allocated by the user.

### 3.2.2 code examples
mstore.c

    long mult2(long, long);
    void multstore(long x, long y, long *dest) {
      long t = mult2(x, y);
      *dest = t;
    }

>gcc -Og -S mstore.c
>
>x/14b multstore
>
>gcc -Og -c mstore.c
>
>objdump -d mstore.o

>gcc -Og -o prog main.c mstore.c

Several features about machine code and its disassembled representation are worth noting:

 * x86-64 instructions can range in length from 1 to 15 bytes. The instruction encoding is designed so that commonly used instructions and those with fewer operands requixe a smaller number Rf bytes than do less common ones or ones with more operands
* The instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions.For example, only the instruction pushq %rbx can start with byte value 53.
* The disassembler determines the assembly code based purely on the byte sequences in the machine-code file. It does not require access to the source or assembly-code versions of the program.
* The disassembler uses a: slightly different naming convention for the instructions than does the assembly code generated by gcc. In our example, it has omitted the suffix 'q' from many of the instructions. These suffixes are size designators and can be omitted in most cases. Conversely, the disassembler adds the suffix 'q' to the call and ret instructions. Again, these suffixes can
safely be omitted.

Some differences:
1. The linker has shifted the location of this code to a different range of addresses.
2. the linker filled in the address that the callq instruction should use in function *mult2*
3. two additional lines of code, nop nop, grow the code for the function to 16 bytes.

### 3.2.3 notes on formatting
All of the lines beginning with '.' are directives to guide the assembler and linker, we can generally ignore these.

>gcc -Og -masm=intel mstore.c

We see that the intel and ATT formats differ in the following ways:

 * The Intel code omits the size designation suffixes, We  see instruction push and mov instead of pushq
and movq.
 * The Intel code omits the '%' character in front of register names, using rbx instead of %rbx.
 * The Intel code has a different way of describing locations in memory-for example, QWORD PTR [rbx] rathen than (%rbx)
 * Instructions With multiple operands list them in the reverse order. This can be very confusing when, switching between the two formats.

## 3.3 data formats
1. Intel uses the term "word" to refer to a 16-bit data type.
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/intel_size_types.png "intel_size_types")

2. combining assembly code with C programs
 * write an entire function as a seperate assembly-code file and let the assembler and linker combine this with code we have written in C
 * use the inline assembly feature of gcc, where brief sections of assembly code can be incorporated into a C program using the *asm* directive.

## 3.4 accessing infomation
An x86-64 central processing unit(CPU) contains 16 general-purpose registers storing 64-bit values. These registers are used to store integer data as well as pointers. (original 8086 had eight 16-bit registers, %ax through %bp)

Two conventions arise for what happens to the remaining bytes in the register for instructions that generate less than 8 bytes : 
 * those that generate 1 or 2 byte quantities leave the remaining bytes unchanged
 * those that generate 4 byte quantities set the upper 4 bytes of the register to zero.

The stack pointer %rsp is used to indicate the end position in the run-time stack.
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/integer_registers.png "integer_registers")

### 3.4.1 operand specifiers
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/operand_forms.png "operand_forms")
operand forms:

 1. immediate, constant values, written with a '$' followed by an integer using standard C notation
 2.  register, denotes the contents of a register.
 3.  memory reference, access some memory location, often called effective address.
 
### 3.4.2 data movement instructions
We group the many different instructions into instruction classes, where the instructions in a class perform the same operation but with different operand sizes.

---
**MOV class**:
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/mov_class.png "mov_class")

* source operand : immediate, stored in a register, or stored in memory;
* destination operand : register or a memory address.

The x86-64 imposes the restriction that a move instruction cannot have both operands refer to memory locations.

    movl $0x12, %eax
    movw %bp, %sp
    movb (%rdi, %rcx), %al
    movb $-1,(%rsp)
    movq %rax, -12(%rbp)

**movq** can only have immediate source operands that can be represented as 32-bit two's-complement numbers. This value is then sign extended to produce the 64-bit value for the destination. The **movabsq** instruction can have an arbitrary 64-bit immediate value as its source operand and can only have a register as a destination.

movabsq  $0x0011223344556677,%rax  %rax=$0x0011223344556677
movb $-1,%al                       %rax=$0x00112233445566FF
movl $-1,%eax                      %rax=$0x00000000FFFFFFFF

---
copy a smaller source value to a larger destination.
* source operand : register or stored in memory
* destination operand : register

**cltq** always uses register %eax as its source and %rax as the destination for the sign-extended result. Same effect : movslq %eax, %rax

###3.4.3 data movement example
1. we see that "pointers" in C are simplt address. Dereferencing a pointer involves copying that pointer into a register, and then using this register in a memory reference.
2. local variables such as x are often kept in registers rather than stored in memory locations.

### 3.4.4 pushing and poping stack data
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/stack_instruction.png "stack_instruction")
The stack grows downward such that the top element of the stack has the lowest address of all stack elements.

    pushq %rbp
    subq $8, %rbp
    movq %rbp, (%rsp)

    popq %rax
    movq (%rax)
    addq $8, %rsp

## 3.5 Arithmetic and Logical operations
Most of the operations are given as instruction classes.
The ops are divided into four groups :

 1. load effective address
 2. unary
 3. binaty
 4. shifts
 
### 3.5.1 Load Effective Address
leaq has the form of an instruction that reads from memory to a register, but it does not reference memory. Its first operand appears to be a memory reference. The instruction copies the effective address to the destination.

### 3.5.2 unary and binary operations
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/arithmetic_instructions.png "arithmetic_instructions")

This single operand of unary operations : register or a memory location. (incq ++)

Binary operations, the second operand is used as both a source and destination.(x -= y).
 
 * First operand : immediate value, register or memory location
 * Second : register or a memory location

### 3.5.3 shift operations
The different shift instructions can specify the shift amount either as an immediate value or with the single-byte register %cl.
With x86-64, a shift instruction operating on data values that are w bits long determines the shift amount from the low-order m bits of register %cl, where 2^m = w.

>%cl=0xFF, salb m=3, 7; salw m=4, 15;

### 3.5.4 discussion
### 3.5.5 special arithmetic operations
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/special_arithmetic.png  "special_arithmetic")

The assembler can tell which one is intended by counting the number of operands.

##3.6 Control
conditionals, loops, switches

1. Two ways of implementing conditional operations(conditional control and conditional move)
2. loops and switch statement

### 3.6.1 Conditional Codes
**Single-bit condition code registers**:

1. CF(Carry flag), the most recent operation generated a carry out of the most significant bit. Used to detect overflow for unsigned ops.
2. ZF(Zero flag), the most recent operation yield zero.
3. SF(sign flag), the most recent operation yield a negative value
4. DF(overflow flag), most recent operation cause a two's-complement overflow-either negative or postive.

**condition code examples**:

Suppose t = a + b, where a,b,t are integers, 
CF (unsigned) t < (unsigned) a  Unsigned overflow
ZF (t == 0)                     zero  
SF (t < 0)                      negative
OF (a<O==b<O) && (t<O !=a<O)    signed overflow


**instructions' effect to condition code**:

1. leaq does not alter any codition codes.
2. all of the instructions listed in 3.10 cause the condition codes to be set.
3. logical ops such as XOR, the carry and overflow flags are set to zero
4. shift ops, the carry flag is set to the last bit shifted out, overflow flag is set to zero.
5. INC and DEC set the overflow and zero flags, leaving the carry flag unchanged.

**instruction classes that set condition codes without altering any other registers**:
![alt text](http://7xp1jz.com1.z0.glb.clouddn.com/csapp/3/condition_code.png "condition_codes")

1. The CMP instructions behave in the same way as the SUB instructions, except that they set the condition codes without updating their destinations. Set the zero flag if the two operands are equal.
2. TEST instructions behave as AND instructions, except that they set the condition codes without updating their destinations.

### 3.6.2 accessing the condition codes


## arithmetic operations
movb, movw, movl, movq
movzbw, movzbl, movzq, movzwl, movzwq
movsbw, movsbl, movesbq, movswl, moveswq, moveslq

pushq S
popq D

leaq S,D 
INC D
DEC D
NEG D
NOT D

ADD S,D
SUB S,D
IMUL S,D
XOR S,D
OR S,D
AND S,D

SAL k, D left shift
SHL k, D left shift(same as SAL)
SAR k, D arithmetic right shift
SHR k, D logical right shift

mulq
imulq
cqto
idivq
divq

##3.6 control
Condition codes:

monotonicity 单调性
penalty 罚款罚金处罚

##Questions
1. How mant bytes is each instructions compiled to in x86 ?
2. How to write an assembly program and compile it ?
3. the implementation of conditional moves in Chapter 4.
